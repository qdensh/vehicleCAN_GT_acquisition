/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.14.0 Tue May 21 09:27:24 2019.
 */

#include <string.h>

#include "c11.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int c11_tire_steering_angle_pack(
    uint8_t *dst_p,
    const struct c11_tire_steering_angle_t *src_p,
    size_t size)
{
    uint16_t tire_steering_angle_sig;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    tire_steering_angle_sig = (uint16_t)src_p->tire_steering_angle_sig;
    dst_p[0] |= pack_left_shift_u16(tire_steering_angle_sig, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(tire_steering_angle_sig, 8u, 0xffu);

    return (2);
}

int c11_tire_steering_angle_unpack(
    struct c11_tire_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t tire_steering_angle_sig;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    tire_steering_angle_sig = 0u;
    tire_steering_angle_sig |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    tire_steering_angle_sig |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tire_steering_angle_sig = (int16_t)tire_steering_angle_sig;

    return (0);
}

int16_t c11_tire_steering_angle_tire_steering_angle_sig_encode(double value)
{
    return (int16_t)(value / 0.00183);
}

double c11_tire_steering_angle_tire_steering_angle_sig_decode(int16_t value)
{
    return ((double)value * 0.00183);
}

bool c11_tire_steering_angle_tire_steering_angle_sig_is_in_range(int16_t value)
{
    return ((value >= -16393) && (value <= 16393));
}

int c11_sasf_status_pack(
    uint8_t *dst_p,
    const struct c11_sasf_status_t *src_p,
    size_t size)
{
    uint16_t sasf_steering_wheel_angle;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    sasf_steering_wheel_angle = (uint16_t)src_p->sasf_steering_wheel_angle;
    dst_p[0] |= pack_right_shift_u16(sasf_steering_wheel_angle, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(sasf_steering_wheel_angle, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->sasf_steering_wheel_angle_speed, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->sasf_reserved_1, 2u, 0xfcu);
    dst_p[3] |= pack_left_shift_u8(src_p->sasf_calibration_status, 0u, 0x01u);

    return (4);
}

int c11_sasf_status_unpack(
    struct c11_sasf_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t sasf_steering_wheel_angle;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    sasf_steering_wheel_angle = 0u;
    sasf_steering_wheel_angle |= unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    sasf_steering_wheel_angle |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->sasf_steering_wheel_angle = (int16_t)sasf_steering_wheel_angle;
    dst_p->sasf_steering_wheel_angle_speed |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->sasf_reserved_1 |= unpack_right_shift_u8(src_p[3], 2u, 0xfcu);
    dst_p->sasf_calibration_status |= unpack_right_shift_u8(src_p[3], 0u, 0x01u);

    return (0);
}

int16_t c11_sasf_status_sasf_steering_wheel_angle_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_sasf_status_sasf_steering_wheel_angle_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_sasf_status_sasf_steering_wheel_angle_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_sasf_status_sasf_steering_wheel_angle_speed_encode(double value)
{
    return (uint8_t)(value / 4.0);
}

double c11_sasf_status_sasf_steering_wheel_angle_speed_decode(uint8_t value)
{
    return ((double)value * 4.0);
}

bool c11_sasf_status_sasf_steering_wheel_angle_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_sasf_status_sasf_reserved_1_encode(double value)
{
    return (uint8_t)(value);
}

double c11_sasf_status_sasf_reserved_1_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_sasf_status_sasf_reserved_1_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_sasf_status_sasf_calibration_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_sasf_status_sasf_calibration_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_sasf_status_sasf_calibration_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int c11_xl_sas_status_pack(
    uint8_t *dst_p,
    const struct c11_xl_sas_status_t *src_p,
    size_t size)
{
    uint16_t val_steer_angle_sas;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    val_steer_angle_sas = (uint16_t)src_p->val_steer_angle_sas;
    dst_p[0] |= pack_left_shift_u16(val_steer_angle_sas, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(val_steer_angle_sas, 8u, 0xffu);

    return (2);
}

int c11_xl_sas_status_unpack(
    struct c11_xl_sas_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t val_steer_angle_sas;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    val_steer_angle_sas = 0u;
    val_steer_angle_sas |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    val_steer_angle_sas |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->val_steer_angle_sas = (int16_t)val_steer_angle_sas;

    return (0);
}

int16_t c11_xl_sas_status_val_steer_angle_sas_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_xl_sas_status_val_steer_angle_sas_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_xl_sas_status_val_steer_angle_sas_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int c11_tbox_vehicle_request_status_pack(
    uint8_t *dst_p,
    const struct c11_tbox_vehicle_request_status_t *src_p,
    size_t size)
{
    uint16_t tbox_st_wheel_angle_req;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->tbox_shift_level_request, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->tbox_drive_mode_request, 6u, 0xc0u);
    tbox_st_wheel_angle_req = (uint16_t)src_p->tbox_st_wheel_angle_req;
    dst_p[1] |= pack_left_shift_u16(tbox_st_wheel_angle_req, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(tbox_st_wheel_angle_req, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->tbox_left_turn_light_request, 0u, 0x03u);
    dst_p[3] |= pack_left_shift_u8(src_p->tbox_right_turn_light_request, 2u, 0x0cu);
    dst_p[3] |= pack_left_shift_u8(src_p->tbox_hazard_light_request, 4u, 0x30u);
    dst_p[4] |= pack_left_shift_u8(src_p->tbox_low_beam_request, 0u, 0x03u);
    dst_p[5] |= pack_left_shift_u16(src_p->tbox_target_speed, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->tbox_target_speed, 8u, 0x03u);
    dst_p[6] |= pack_left_shift_u8(src_p->tbox_ebrake_request, 2u, 0x04u);

    return (8);
}

int c11_tbox_vehicle_request_status_unpack(
    struct c11_tbox_vehicle_request_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t tbox_st_wheel_angle_req;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->tbox_shift_level_request |= unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->tbox_drive_mode_request |= unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    tbox_st_wheel_angle_req = 0u;
    tbox_st_wheel_angle_req |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    tbox_st_wheel_angle_req |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->tbox_st_wheel_angle_req = (int16_t)tbox_st_wheel_angle_req;
    dst_p->tbox_left_turn_light_request |= unpack_right_shift_u8(src_p[3], 0u, 0x03u);
    dst_p->tbox_right_turn_light_request |= unpack_right_shift_u8(src_p[3], 2u, 0x0cu);
    dst_p->tbox_hazard_light_request |= unpack_right_shift_u8(src_p[3], 4u, 0x30u);
    dst_p->tbox_low_beam_request |= unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->tbox_target_speed |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->tbox_target_speed |= unpack_left_shift_u16(src_p[6], 8u, 0x03u);
    dst_p->tbox_ebrake_request |= unpack_right_shift_u8(src_p[6], 2u, 0x04u);

    return (0);
}

uint8_t c11_tbox_vehicle_request_status_tbox_shift_level_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_shift_level_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_shift_level_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_tbox_vehicle_request_status_tbox_drive_mode_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_drive_mode_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_drive_mode_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int16_t c11_tbox_vehicle_request_status_tbox_st_wheel_angle_req_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_tbox_vehicle_request_status_tbox_st_wheel_angle_req_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_tbox_vehicle_request_status_tbox_st_wheel_angle_req_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_tbox_vehicle_request_status_tbox_left_turn_light_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_left_turn_light_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_left_turn_light_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_tbox_vehicle_request_status_tbox_right_turn_light_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_right_turn_light_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_right_turn_light_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_tbox_vehicle_request_status_tbox_hazard_light_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_hazard_light_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_hazard_light_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_tbox_vehicle_request_status_tbox_low_beam_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_low_beam_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_low_beam_request_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint16_t c11_tbox_vehicle_request_status_tbox_target_speed_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double c11_tbox_vehicle_request_status_tbox_target_speed_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool c11_tbox_vehicle_request_status_tbox_target_speed_is_in_range(uint16_t value)
{
    return (value <= 510u);
}

uint8_t c11_tbox_vehicle_request_status_tbox_ebrake_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_tbox_vehicle_request_status_tbox_ebrake_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_tbox_vehicle_request_status_tbox_ebrake_request_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int c11_ibc_status_pack(
    uint8_t *dst_p,
    const struct c11_ibc_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ibc_system_status, 0u, 0x03u);
    dst_p[2] |= pack_left_shift_u16(src_p->ibc_hp_pressure, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->ibc_hp_pressure, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->ibc_fault_code, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->ibc_fault_code, 8u, 0xffu);

    return (8);
}

int c11_ibc_status_unpack(
    struct c11_ibc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->ibc_system_status |= unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->ibc_hp_pressure |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->ibc_hp_pressure |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->ibc_fault_code |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->ibc_fault_code |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

uint8_t c11_ibc_status_ibc_system_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_ibc_status_ibc_system_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_ibc_status_ibc_system_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint16_t c11_ibc_status_ibc_hp_pressure_encode(double value)
{
    return (uint16_t)(value / 0.00244);
}

double c11_ibc_status_ibc_hp_pressure_decode(uint16_t value)
{
    return ((double)value * 0.00244);
}

bool c11_ibc_status_ibc_hp_pressure_is_in_range(uint16_t value)
{
    return (value <= 4098u);
}

uint16_t c11_ibc_status_ibc_fault_code_encode(double value)
{
    return (uint16_t)(value);
}

double c11_ibc_status_ibc_fault_code_decode(uint16_t value)
{
    return ((double)value);
}

bool c11_ibc_status_ibc_fault_code_is_in_range(uint16_t value)
{
    return (value <= 32265u);
}

int c11_epsr_status_pack(
    uint8_t *dst_p,
    const struct c11_epsr_status_t *src_p,
    size_t size)
{
    uint16_t epsr_actual_st_wheel_ang;
    uint8_t epsr_actual_st_whl_angle_sp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    epsr_actual_st_wheel_ang = (uint16_t)src_p->epsr_actual_st_wheel_ang;
    dst_p[0] |= pack_left_shift_u16(epsr_actual_st_wheel_ang, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(epsr_actual_st_wheel_ang, 8u, 0xffu);
    epsr_actual_st_whl_angle_sp = (uint8_t)src_p->epsr_actual_st_whl_angle_sp;
    dst_p[2] |= pack_left_shift_u8(epsr_actual_st_whl_angle_sp, 0u, 0xffu);

    return (8);
}

int c11_epsr_status_unpack(
    struct c11_epsr_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t epsr_actual_st_wheel_ang;
    uint8_t epsr_actual_st_whl_angle_sp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    epsr_actual_st_wheel_ang = 0u;
    epsr_actual_st_wheel_ang |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    epsr_actual_st_wheel_ang |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->epsr_actual_st_wheel_ang = (int16_t)epsr_actual_st_wheel_ang;
    epsr_actual_st_whl_angle_sp = 0u;
    epsr_actual_st_whl_angle_sp |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->epsr_actual_st_whl_angle_sp = (int8_t)epsr_actual_st_whl_angle_sp;

    return (0);
}

int16_t c11_epsr_status_epsr_actual_st_wheel_ang_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_epsr_status_epsr_actual_st_wheel_ang_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_epsr_status_epsr_actual_st_wheel_ang_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int8_t c11_epsr_status_epsr_actual_st_whl_angle_sp_encode(double value)
{
    return (int8_t)(value / 8.0);
}

double c11_epsr_status_epsr_actual_st_whl_angle_sp_decode(int8_t value)
{
    return ((double)value * 8.0);
}

bool c11_epsr_status_epsr_actual_st_whl_angle_sp_is_in_range(int8_t value)
{
    return (value >= -127);
}

int c11_epsf_status_pack(
    uint8_t *dst_p,
    const struct c11_epsf_status_t *src_p,
    size_t size)
{
    uint16_t epsf_actual_st_whl_ang;
    uint8_t epsf_actual_st_whl_angle_sp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    epsf_actual_st_whl_ang = (uint16_t)src_p->epsf_actual_st_whl_ang;
    dst_p[0] |= pack_left_shift_u16(epsf_actual_st_whl_ang, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(epsf_actual_st_whl_ang, 8u, 0xffu);
    epsf_actual_st_whl_angle_sp = (uint8_t)src_p->epsf_actual_st_whl_angle_sp;
    dst_p[2] |= pack_left_shift_u8(epsf_actual_st_whl_angle_sp, 0u, 0xffu);

    return (8);
}

int c11_epsf_status_unpack(
    struct c11_epsf_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t epsf_actual_st_whl_ang;
    uint8_t epsf_actual_st_whl_angle_sp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    epsf_actual_st_whl_ang = 0u;
    epsf_actual_st_whl_ang |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    epsf_actual_st_whl_ang |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->epsf_actual_st_whl_ang = (int16_t)epsf_actual_st_whl_ang;
    epsf_actual_st_whl_angle_sp = 0u;
    epsf_actual_st_whl_angle_sp |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->epsf_actual_st_whl_angle_sp = (int8_t)epsf_actual_st_whl_angle_sp;

    return (0);
}

int16_t c11_epsf_status_epsf_actual_st_whl_ang_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_epsf_status_epsf_actual_st_whl_ang_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_epsf_status_epsf_actual_st_whl_ang_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int8_t c11_epsf_status_epsf_actual_st_whl_angle_sp_encode(double value)
{
    return (int8_t)(value / 8.0);
}

double c11_epsf_status_epsf_actual_st_whl_angle_sp_decode(int8_t value)
{
    return ((double)value * 8.0);
}

bool c11_epsf_status_epsf_actual_st_whl_angle_sp_is_in_range(int8_t value)
{
    return (value >= -127);
}

int c11_vcu_activate_battery_request_pack(
    uint8_t *dst_p,
    const struct c11_vcu_activate_battery_request_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_activate_battery_request, 0u, 0xffu);

    return (8);
}

int c11_vcu_activate_battery_request_unpack(
    struct c11_vcu_activate_battery_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->vcu_activate_battery_request |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t c11_vcu_activate_battery_request_vcu_activate_battery_request_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_activate_battery_request_vcu_activate_battery_request_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_activate_battery_request_vcu_activate_battery_request_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int c11_vcu_mcur_battery_request_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcur_battery_request_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->dc_link_imax_discharge, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dc_link_imax_discharge, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->dc_link_imax_recharge, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->dc_link_imax_recharge, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->dc_link_voltage_target, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->dc_link_voltage_target, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcur_battery_request_unpack(
    struct c11_vcu_mcur_battery_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->dc_link_imax_discharge |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dc_link_imax_discharge |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dc_link_imax_recharge |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->dc_link_imax_recharge |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->dc_link_voltage_target |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->dc_link_voltage_target |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

uint16_t c11_vcu_mcur_battery_request_dc_link_imax_discharge_encode(double value)
{
    return (uint16_t)(value);
}

double c11_vcu_mcur_battery_request_dc_link_imax_discharge_decode(uint16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcur_battery_request_dc_link_imax_discharge_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

uint16_t c11_vcu_mcur_battery_request_dc_link_imax_recharge_encode(double value)
{
    return (uint16_t)(value - -1000.0);
}

double c11_vcu_mcur_battery_request_dc_link_imax_recharge_decode(uint16_t value)
{
    return ((double)value + -1000.0);
}

bool c11_vcu_mcur_battery_request_dc_link_imax_recharge_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

uint16_t c11_vcu_mcur_battery_request_dc_link_voltage_target_encode(double value)
{
    return (uint16_t)(value / 0.0625);
}

double c11_vcu_mcur_battery_request_dc_link_voltage_target_decode(uint16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcur_battery_request_dc_link_voltage_target_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int c11_vcu_mcur_request_2_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcur_request_2_t *src_p,
    size_t size)
{
    uint16_t vcu_mcur_speed_limit_forward;
    uint16_t vcu_mcur_speed_limit_reverse;
    uint16_t vcu_mcur_tq_current_reg_lim;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vcu_mcur_tq_current_reg_lim = (uint16_t)src_p->vcu_mcur_tq_current_reg_lim;
    dst_p[0] |= pack_left_shift_u16(vcu_mcur_tq_current_reg_lim, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vcu_mcur_tq_current_reg_lim, 8u, 0xffu);
    vcu_mcur_speed_limit_forward = (uint16_t)src_p->vcu_mcur_speed_limit_forward;
    dst_p[2] |= pack_left_shift_u16(vcu_mcur_speed_limit_forward, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(vcu_mcur_speed_limit_forward, 8u, 0xffu);
    vcu_mcur_speed_limit_reverse = (uint16_t)src_p->vcu_mcur_speed_limit_reverse;
    dst_p[4] |= pack_left_shift_u16(vcu_mcur_speed_limit_reverse, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vcu_mcur_speed_limit_reverse, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcur_request_2_unpack(
    struct c11_vcu_mcur_request_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vcu_mcur_speed_limit_forward;
    uint16_t vcu_mcur_speed_limit_reverse;
    uint16_t vcu_mcur_tq_current_reg_lim;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vcu_mcur_tq_current_reg_lim = 0u;
    vcu_mcur_tq_current_reg_lim |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vcu_mcur_tq_current_reg_lim |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vcu_mcur_tq_current_reg_lim = (int16_t)vcu_mcur_tq_current_reg_lim;
    vcu_mcur_speed_limit_forward = 0u;
    vcu_mcur_speed_limit_forward |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    vcu_mcur_speed_limit_forward |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->vcu_mcur_speed_limit_forward = (int16_t)vcu_mcur_speed_limit_forward;
    vcu_mcur_speed_limit_reverse = 0u;
    vcu_mcur_speed_limit_reverse |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vcu_mcur_speed_limit_reverse |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vcu_mcur_speed_limit_reverse = (int16_t)vcu_mcur_speed_limit_reverse;

    return (0);
}

int16_t c11_vcu_mcur_request_2_vcu_mcur_tq_current_reg_lim_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcur_request_2_vcu_mcur_tq_current_reg_lim_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcur_request_2_vcu_mcur_tq_current_reg_lim_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_vcu_mcur_request_2_vcu_mcur_speed_limit_forward_encode(double value)
{
    return (int16_t)(value);
}

double c11_vcu_mcur_request_2_vcu_mcur_speed_limit_forward_decode(int16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcur_request_2_vcu_mcur_speed_limit_forward_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t c11_vcu_mcur_request_2_vcu_mcur_speed_limit_reverse_encode(double value)
{
    return (int16_t)(value);
}

double c11_vcu_mcur_request_2_vcu_mcur_speed_limit_reverse_decode(int16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcur_request_2_vcu_mcur_speed_limit_reverse_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int c11_vcu_mcur_request_1_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcur_request_1_t *src_p,
    size_t size)
{
    uint16_t vcu_torque_current_trac_lim;
    uint16_t vcu_torque_request;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vcu_torque_request = (uint16_t)src_p->vcu_torque_request;
    dst_p[0] |= pack_left_shift_u16(vcu_torque_request, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vcu_torque_request, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_torque_request_control_word, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_control_motor_r_rot_dir, 0u, 0xffu);
    vcu_torque_current_trac_lim = (uint16_t)src_p->vcu_torque_current_trac_lim;
    dst_p[4] |= pack_left_shift_u16(vcu_torque_current_trac_lim, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vcu_torque_current_trac_lim, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcur_request_1_unpack(
    struct c11_vcu_mcur_request_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vcu_torque_current_trac_lim;
    uint16_t vcu_torque_request;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vcu_torque_request = 0u;
    vcu_torque_request |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vcu_torque_request |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vcu_torque_request = (int16_t)vcu_torque_request;
    dst_p->vcu_torque_request_control_word |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->vcu_control_motor_r_rot_dir |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    vcu_torque_current_trac_lim = 0u;
    vcu_torque_current_trac_lim |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vcu_torque_current_trac_lim |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vcu_torque_current_trac_lim = (int16_t)vcu_torque_current_trac_lim;

    return (0);
}

int16_t c11_vcu_mcur_request_1_vcu_torque_request_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcur_request_1_vcu_torque_request_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcur_request_1_vcu_torque_request_is_in_range(int16_t value)
{
    return (value <= 32766);
}

uint8_t c11_vcu_mcur_request_1_vcu_torque_request_control_word_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_mcur_request_1_vcu_torque_request_control_word_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_mcur_request_1_vcu_torque_request_control_word_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_vcu_mcur_request_1_vcu_control_motor_r_rot_dir_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_mcur_request_1_vcu_control_motor_r_rot_dir_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_mcur_request_1_vcu_control_motor_r_rot_dir_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t c11_vcu_mcur_request_1_vcu_torque_current_trac_lim_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcur_request_1_vcu_torque_current_trac_lim_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcur_request_1_vcu_torque_current_trac_lim_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int c11_vcu_mcuf_request_2_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcuf_request_2_t *src_p,
    size_t size)
{
    uint16_t vcu_mcuf_speed_limit_forward;
    uint16_t vcu_mcuf_speed_limit_reverse;
    uint16_t vcu_mcuf_tq_current_reg_lim;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vcu_mcuf_tq_current_reg_lim = (uint16_t)src_p->vcu_mcuf_tq_current_reg_lim;
    dst_p[0] |= pack_left_shift_u16(vcu_mcuf_tq_current_reg_lim, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vcu_mcuf_tq_current_reg_lim, 8u, 0xffu);
    vcu_mcuf_speed_limit_forward = (uint16_t)src_p->vcu_mcuf_speed_limit_forward;
    dst_p[2] |= pack_left_shift_u16(vcu_mcuf_speed_limit_forward, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(vcu_mcuf_speed_limit_forward, 8u, 0xffu);
    vcu_mcuf_speed_limit_reverse = (uint16_t)src_p->vcu_mcuf_speed_limit_reverse;
    dst_p[4] |= pack_left_shift_u16(vcu_mcuf_speed_limit_reverse, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vcu_mcuf_speed_limit_reverse, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcuf_request_2_unpack(
    struct c11_vcu_mcuf_request_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vcu_mcuf_speed_limit_forward;
    uint16_t vcu_mcuf_speed_limit_reverse;
    uint16_t vcu_mcuf_tq_current_reg_lim;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vcu_mcuf_tq_current_reg_lim = 0u;
    vcu_mcuf_tq_current_reg_lim |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vcu_mcuf_tq_current_reg_lim |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vcu_mcuf_tq_current_reg_lim = (int16_t)vcu_mcuf_tq_current_reg_lim;
    vcu_mcuf_speed_limit_forward = 0u;
    vcu_mcuf_speed_limit_forward |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    vcu_mcuf_speed_limit_forward |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->vcu_mcuf_speed_limit_forward = (int16_t)vcu_mcuf_speed_limit_forward;
    vcu_mcuf_speed_limit_reverse = 0u;
    vcu_mcuf_speed_limit_reverse |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vcu_mcuf_speed_limit_reverse |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vcu_mcuf_speed_limit_reverse = (int16_t)vcu_mcuf_speed_limit_reverse;

    return (0);
}

int16_t c11_vcu_mcuf_request_2_vcu_mcuf_tq_current_reg_lim_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcuf_request_2_vcu_mcuf_tq_current_reg_lim_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcuf_request_2_vcu_mcuf_tq_current_reg_lim_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_forward_encode(double value)
{
    return (int16_t)(value);
}

double c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_forward_decode(int16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_forward_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_reverse_encode(double value)
{
    return (int16_t)(value);
}

double c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_reverse_decode(int16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcuf_request_2_vcu_mcuf_speed_limit_reverse_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int c11_vcu_mcuf_battery_request_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcuf_battery_request_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->dc_link_imax_discharge, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dc_link_imax_discharge, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->dc_link_imax_recharge, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->dc_link_imax_recharge, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->dc_link_voltage_target, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->dc_link_voltage_target, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcuf_battery_request_unpack(
    struct c11_vcu_mcuf_battery_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->dc_link_imax_discharge |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dc_link_imax_discharge |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dc_link_imax_recharge |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->dc_link_imax_recharge |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->dc_link_voltage_target |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->dc_link_voltage_target |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

uint16_t c11_vcu_mcuf_battery_request_dc_link_imax_discharge_encode(double value)
{
    return (uint16_t)(value);
}

double c11_vcu_mcuf_battery_request_dc_link_imax_discharge_decode(uint16_t value)
{
    return ((double)value);
}

bool c11_vcu_mcuf_battery_request_dc_link_imax_discharge_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

uint16_t c11_vcu_mcuf_battery_request_dc_link_imax_recharge_encode(double value)
{
    return (uint16_t)(value - -1000.0);
}

double c11_vcu_mcuf_battery_request_dc_link_imax_recharge_decode(uint16_t value)
{
    return ((double)value + -1000.0);
}

bool c11_vcu_mcuf_battery_request_dc_link_imax_recharge_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

uint16_t c11_vcu_mcuf_battery_request_dc_link_voltage_target_encode(double value)
{
    return (uint16_t)(value / 0.0625);
}

double c11_vcu_mcuf_battery_request_dc_link_voltage_target_decode(uint16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcuf_battery_request_dc_link_voltage_target_is_in_range(uint16_t value)
{
    return (value <= 16000u);
}

int c11_vcu_mcuf_request_1_pack(
    uint8_t *dst_p,
    const struct c11_vcu_mcuf_request_1_t *src_p,
    size_t size)
{
    uint16_t vcu_torque_current_tra_limit;
    uint16_t vcu_torque_request;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vcu_torque_request = (uint16_t)src_p->vcu_torque_request;
    dst_p[0] |= pack_left_shift_u16(vcu_torque_request, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vcu_torque_request, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_torque_request_control_word, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_control_motor_f_rot_dir, 0u, 0xffu);
    vcu_torque_current_tra_limit = (uint16_t)src_p->vcu_torque_current_tra_limit;
    dst_p[4] |= pack_left_shift_u16(vcu_torque_current_tra_limit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vcu_torque_current_tra_limit, 8u, 0xffu);

    return (8);
}

int c11_vcu_mcuf_request_1_unpack(
    struct c11_vcu_mcuf_request_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vcu_torque_current_tra_limit;
    uint16_t vcu_torque_request;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vcu_torque_request = 0u;
    vcu_torque_request |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vcu_torque_request |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vcu_torque_request = (int16_t)vcu_torque_request;
    dst_p->vcu_torque_request_control_word |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->vcu_control_motor_f_rot_dir |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    vcu_torque_current_tra_limit = 0u;
    vcu_torque_current_tra_limit |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vcu_torque_current_tra_limit |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vcu_torque_current_tra_limit = (int16_t)vcu_torque_current_tra_limit;

    return (0);
}

int16_t c11_vcu_mcuf_request_1_vcu_torque_request_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcuf_request_1_vcu_torque_request_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcuf_request_1_vcu_torque_request_is_in_range(int16_t value)
{
    return (value <= 32766);
}

uint8_t c11_vcu_mcuf_request_1_vcu_torque_request_control_word_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_mcuf_request_1_vcu_torque_request_control_word_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_mcuf_request_1_vcu_torque_request_control_word_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_vcu_mcuf_request_1_vcu_control_motor_f_rot_dir_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_mcuf_request_1_vcu_control_motor_f_rot_dir_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_mcuf_request_1_vcu_control_motor_f_rot_dir_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t c11_vcu_mcuf_request_1_vcu_torque_current_tra_limit_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_vcu_mcuf_request_1_vcu_torque_current_tra_limit_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_vcu_mcuf_request_1_vcu_torque_current_tra_limit_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int c11_vcu_ibc_request_pack(
    uint8_t *dst_p,
    const struct c11_vcu_ibc_request_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[2] |= pack_left_shift_u8(src_p->vcu_break_pressure_request_value, 1u, 0x02u);
    dst_p[5] |= pack_left_shift_u16(src_p->vcu_break_pressure_request, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->vcu_break_pressure_request, 8u, 0xffu);

    return (8);
}

int c11_vcu_ibc_request_unpack(
    struct c11_vcu_ibc_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->vcu_break_pressure_request_value |= unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->vcu_break_pressure_request |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->vcu_break_pressure_request |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t c11_vcu_ibc_request_vcu_break_pressure_request_value_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_ibc_request_vcu_break_pressure_request_value_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_ibc_request_vcu_break_pressure_request_value_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t c11_vcu_ibc_request_vcu_break_pressure_request_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double c11_vcu_ibc_request_vcu_break_pressure_request_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool c11_vcu_ibc_request_vcu_break_pressure_request_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

int c11_vcu_eps_request_pack(
    uint8_t *dst_p,
    const struct c11_vcu_eps_request_t *src_p,
    size_t size)
{
    uint16_t eps_angle_req;
    uint32_t eps_reserved;
    uint8_t eps_check_sum;
    uint8_t eps_speed_req;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    eps_angle_req = (uint16_t)src_p->eps_angle_req;
    dst_p[0] |= pack_left_shift_u16(eps_angle_req, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(eps_angle_req, 8u, 0xffu);
    eps_speed_req = (uint8_t)src_p->eps_speed_req;
    dst_p[2] |= pack_left_shift_u8(eps_speed_req, 0u, 0xffu);
    eps_reserved = (uint32_t)src_p->eps_reserved;
    dst_p[3] |= pack_left_shift_u32(eps_reserved, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(eps_reserved, 8u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(eps_reserved, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(eps_reserved, 24u, 0xffu);
    eps_check_sum = (uint8_t)src_p->eps_check_sum;
    dst_p[7] |= pack_left_shift_u8(eps_check_sum, 0u, 0xffu);

    return (8);
}

int c11_vcu_eps_request_unpack(
    struct c11_vcu_eps_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t eps_angle_req;
    uint32_t eps_reserved;
    uint8_t eps_check_sum;
    uint8_t eps_speed_req;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    eps_angle_req = 0u;
    eps_angle_req |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    eps_angle_req |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->eps_angle_req = (int16_t)eps_angle_req;
    eps_speed_req = 0u;
    eps_speed_req |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->eps_speed_req = (int8_t)eps_speed_req;
    eps_reserved = 0u;
    eps_reserved |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    eps_reserved |= unpack_left_shift_u32(src_p[4], 8u, 0xffu);
    eps_reserved |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    eps_reserved |= unpack_left_shift_u32(src_p[6], 24u, 0xffu);
    dst_p->eps_reserved = (int32_t)eps_reserved;
    eps_check_sum = 0u;
    eps_check_sum |= unpack_right_shift_u8(src_p[7], 0u, 0xffu);
    dst_p->eps_check_sum = (int8_t)eps_check_sum;

    return (0);
}

int16_t c11_vcu_eps_request_eps_angle_req_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_vcu_eps_request_eps_angle_req_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_vcu_eps_request_eps_angle_req_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int8_t c11_vcu_eps_request_eps_speed_req_encode(double value)
{
    return (int8_t)(value);
}

double c11_vcu_eps_request_eps_speed_req_decode(int8_t value)
{
    return ((double)value);
}

bool c11_vcu_eps_request_eps_speed_req_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int32_t c11_vcu_eps_request_eps_reserved_encode(double value)
{
    return (int32_t)(value);
}

double c11_vcu_eps_request_eps_reserved_decode(int32_t value)
{
    return ((double)value);
}

bool c11_vcu_eps_request_eps_reserved_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int8_t c11_vcu_eps_request_eps_check_sum_encode(double value)
{
    return (int8_t)(value);
}

double c11_vcu_eps_request_eps_check_sum_decode(int8_t value)
{
    return ((double)value);
}

bool c11_vcu_eps_request_eps_check_sum_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int c11_vcu_status_1_pack(
    uint8_t *dst_p,
    const struct c11_vcu_status_1_t *src_p,
    size_t size)
{
    uint16_t vcu_vehicle_speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_ignition_ststus, 3u, 0x18u);
    vcu_vehicle_speed = (uint16_t)src_p->vcu_vehicle_speed;
    dst_p[2] |= pack_left_shift_u16(vcu_vehicle_speed, 4u, 0xf0u);
    dst_p[3] |= pack_right_shift_u16(vcu_vehicle_speed, 4u, 0x1fu);

    return (8);
}

int c11_vcu_status_1_unpack(
    struct c11_vcu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vcu_vehicle_speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->vcu_ignition_ststus |= unpack_right_shift_u8(src_p[0], 3u, 0x18u);
    vcu_vehicle_speed = 0u;
    vcu_vehicle_speed |= unpack_right_shift_u16(src_p[2], 4u, 0xf0u);
    vcu_vehicle_speed |= unpack_left_shift_u16(src_p[3], 4u, 0x1fu);

    if ((vcu_vehicle_speed & (1u << 8)) != 0u) {
        vcu_vehicle_speed |= 0xfe00u;
    }

    dst_p->vcu_vehicle_speed = (int16_t)vcu_vehicle_speed;

    return (0);
}

uint8_t c11_vcu_status_1_vcu_ignition_ststus_encode(double value)
{
    return (uint8_t)(value);
}

double c11_vcu_status_1_vcu_ignition_ststus_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_vcu_status_1_vcu_ignition_ststus_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int16_t c11_vcu_status_1_vcu_vehicle_speed_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double c11_vcu_status_1_vcu_vehicle_speed_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool c11_vcu_status_1_vcu_vehicle_speed_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 510));
}

int c11_bms2_system_info_pack(
    uint8_t *dst_p,
    const struct c11_bms2_system_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->bms2_battery_out_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->bms2_battery_out_voltage, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->bms2_battery_out_current, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->bms2_battery_out_current, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->bms2_sys_soc, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->bms2_sys_status, 0u, 0x07u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms2_charge_status, 3u, 0x18u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms2_discharging_mos_status, 5u, 0x20u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms2_charging_mos_status, 6u, 0x40u);
    dst_p[6] |= pack_left_shift_u8(src_p->bms2_precharge_signal_status, 0u, 0x03u);

    return (8);
}

int c11_bms2_system_info_unpack(
    struct c11_bms2_system_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->bms2_battery_out_voltage |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->bms2_battery_out_voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->bms2_battery_out_current |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->bms2_battery_out_current |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->bms2_sys_soc |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->bms2_sys_status |= unpack_right_shift_u8(src_p[5], 0u, 0x07u);
    dst_p->bms2_charge_status |= unpack_right_shift_u8(src_p[5], 3u, 0x18u);
    dst_p->bms2_discharging_mos_status |= unpack_right_shift_u8(src_p[5], 5u, 0x20u);
    dst_p->bms2_charging_mos_status |= unpack_right_shift_u8(src_p[5], 6u, 0x40u);
    dst_p->bms2_precharge_signal_status |= unpack_right_shift_u8(src_p[6], 0u, 0x03u);

    return (0);
}

uint16_t c11_bms2_system_info_bms2_battery_out_voltage_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double c11_bms2_system_info_bms2_battery_out_voltage_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool c11_bms2_system_info_bms2_battery_out_voltage_is_in_range(uint16_t value)
{
    return (value <= 5000u);
}

uint16_t c11_bms2_system_info_bms2_battery_out_current_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double c11_bms2_system_info_bms2_battery_out_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool c11_bms2_system_info_bms2_battery_out_current_is_in_range(uint16_t value)
{
    return (value <= 6000u);
}

uint8_t c11_bms2_system_info_bms2_sys_soc_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double c11_bms2_system_info_bms2_sys_soc_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool c11_bms2_system_info_bms2_sys_soc_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t c11_bms2_system_info_bms2_sys_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms2_system_info_bms2_sys_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms2_system_info_bms2_sys_status_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t c11_bms2_system_info_bms2_charge_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms2_system_info_bms2_charge_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms2_system_info_bms2_charge_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_bms2_system_info_bms2_discharging_mos_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms2_system_info_bms2_discharging_mos_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms2_system_info_bms2_discharging_mos_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t c11_bms2_system_info_bms2_charging_mos_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms2_system_info_bms2_charging_mos_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms2_system_info_bms2_charging_mos_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t c11_bms2_system_info_bms2_precharge_signal_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms2_system_info_bms2_precharge_signal_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms2_system_info_bms2_precharge_signal_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int c11_bms1_system_info_pack(
    uint8_t *dst_p,
    const struct c11_bms1_system_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->bms1_battery_out_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->bms1_battery_out_voltage, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->bms1_battery_out_current, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->bms1_battery_out_current, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->bms1_sys_soc, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->bms1_sys_status, 0u, 0x07u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms1_charge_status, 3u, 0x18u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms1_discharging_mos_status, 5u, 0x20u);
    dst_p[5] |= pack_left_shift_u8(src_p->bms1_charging_mos_status, 6u, 0x40u);
    dst_p[6] |= pack_left_shift_u8(src_p->bms1_precharge_signal_status, 0u, 0x03u);

    return (8);
}

int c11_bms1_system_info_unpack(
    struct c11_bms1_system_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->bms1_battery_out_voltage |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->bms1_battery_out_voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->bms1_battery_out_current |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->bms1_battery_out_current |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->bms1_sys_soc |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->bms1_sys_status |= unpack_right_shift_u8(src_p[5], 0u, 0x07u);
    dst_p->bms1_charge_status |= unpack_right_shift_u8(src_p[5], 3u, 0x18u);
    dst_p->bms1_discharging_mos_status |= unpack_right_shift_u8(src_p[5], 5u, 0x20u);
    dst_p->bms1_charging_mos_status |= unpack_right_shift_u8(src_p[5], 6u, 0x40u);
    dst_p->bms1_precharge_signal_status |= unpack_right_shift_u8(src_p[6], 0u, 0x03u);

    return (0);
}

uint16_t c11_bms1_system_info_bms1_battery_out_voltage_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double c11_bms1_system_info_bms1_battery_out_voltage_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool c11_bms1_system_info_bms1_battery_out_voltage_is_in_range(uint16_t value)
{
    return (value <= 5000u);
}

uint16_t c11_bms1_system_info_bms1_battery_out_current_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double c11_bms1_system_info_bms1_battery_out_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool c11_bms1_system_info_bms1_battery_out_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t c11_bms1_system_info_bms1_sys_soc_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double c11_bms1_system_info_bms1_sys_soc_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool c11_bms1_system_info_bms1_sys_soc_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t c11_bms1_system_info_bms1_sys_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms1_system_info_bms1_sys_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms1_system_info_bms1_sys_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_bms1_system_info_bms1_charge_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms1_system_info_bms1_charge_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms1_system_info_bms1_charge_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t c11_bms1_system_info_bms1_discharging_mos_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms1_system_info_bms1_discharging_mos_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms1_system_info_bms1_discharging_mos_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t c11_bms1_system_info_bms1_charging_mos_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms1_system_info_bms1_charging_mos_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms1_system_info_bms1_charging_mos_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t c11_bms1_system_info_bms1_precharge_signal_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_bms1_system_info_bms1_precharge_signal_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_bms1_system_info_bms1_precharge_signal_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int c11_mcur_status_feedback_pack(
    uint8_t *dst_p,
    const struct c11_mcur_status_feedback_t *src_p,
    size_t size)
{
    uint16_t torque_current_available_forward;
    uint16_t torque_current_available_reverse;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    torque_current_available_forward = (uint16_t)src_p->torque_current_available_forward;
    dst_p[0] |= pack_left_shift_u16(torque_current_available_forward, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(torque_current_available_forward, 8u, 0xffu);
    torque_current_available_reverse = (uint16_t)src_p->torque_current_available_reverse;
    dst_p[2] |= pack_left_shift_u16(torque_current_available_reverse, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(torque_current_available_reverse, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->inverter_status, 0u, 0xffu);

    return (8);
}

int c11_mcur_status_feedback_unpack(
    struct c11_mcur_status_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t torque_current_available_forward;
    uint16_t torque_current_available_reverse;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    torque_current_available_forward = 0u;
    torque_current_available_forward |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    torque_current_available_forward |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->torque_current_available_forward = (int16_t)torque_current_available_forward;
    torque_current_available_reverse = 0u;
    torque_current_available_reverse |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    torque_current_available_reverse |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->torque_current_available_reverse = (int16_t)torque_current_available_reverse;
    dst_p->inverter_status |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int16_t c11_mcur_status_feedback_torque_current_available_forward_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcur_status_feedback_torque_current_available_forward_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcur_status_feedback_torque_current_available_forward_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_mcur_status_feedback_torque_current_available_reverse_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcur_status_feedback_torque_current_available_reverse_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcur_status_feedback_torque_current_available_reverse_is_in_range(int16_t value)
{
    return (value <= 32766);
}

uint8_t c11_mcur_status_feedback_inverter_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_mcur_status_feedback_inverter_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_mcur_status_feedback_inverter_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int c11_mcur_torque_feedback_pack(
    uint8_t *dst_p,
    const struct c11_mcur_torque_feedback_t *src_p,
    size_t size)
{
    uint16_t dc_link_current;
    uint16_t speed_measured;
    uint16_t torque_current_measured;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    torque_current_measured = (uint16_t)src_p->torque_current_measured;
    dst_p[0] |= pack_left_shift_u16(torque_current_measured, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(torque_current_measured, 8u, 0xffu);
    speed_measured = (uint16_t)src_p->speed_measured;
    dst_p[2] |= pack_left_shift_u16(speed_measured, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(speed_measured, 8u, 0xffu);
    dc_link_current = (uint16_t)src_p->dc_link_current;
    dst_p[4] |= pack_left_shift_u16(dc_link_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(dc_link_current, 8u, 0xffu);

    return (8);
}

int c11_mcur_torque_feedback_unpack(
    struct c11_mcur_torque_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t dc_link_current;
    uint16_t speed_measured;
    uint16_t torque_current_measured;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    torque_current_measured = 0u;
    torque_current_measured |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    torque_current_measured |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->torque_current_measured = (int16_t)torque_current_measured;
    speed_measured = 0u;
    speed_measured |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    speed_measured |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->speed_measured = (int16_t)speed_measured;
    dc_link_current = 0u;
    dc_link_current |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dc_link_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->dc_link_current = (int16_t)dc_link_current;

    return (0);
}

int16_t c11_mcur_torque_feedback_torque_current_measured_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcur_torque_feedback_torque_current_measured_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcur_torque_feedback_torque_current_measured_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_mcur_torque_feedback_speed_measured_encode(double value)
{
    return (int16_t)(value);
}

double c11_mcur_torque_feedback_speed_measured_decode(int16_t value)
{
    return ((double)value);
}

bool c11_mcur_torque_feedback_speed_measured_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t c11_mcur_torque_feedback_dc_link_current_encode(double value)
{
    return (int16_t)(value);
}

double c11_mcur_torque_feedback_dc_link_current_decode(int16_t value)
{
    return ((double)value);
}

bool c11_mcur_torque_feedback_dc_link_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int c11_mcuf_status_feedback_pack(
    uint8_t *dst_p,
    const struct c11_mcuf_status_feedback_t *src_p,
    size_t size)
{
    uint16_t torque_current_available_forward;
    uint16_t torque_current_available_reverse;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    torque_current_available_forward = (uint16_t)src_p->torque_current_available_forward;
    dst_p[0] |= pack_left_shift_u16(torque_current_available_forward, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(torque_current_available_forward, 8u, 0xffu);
    torque_current_available_reverse = (uint16_t)src_p->torque_current_available_reverse;
    dst_p[2] |= pack_left_shift_u16(torque_current_available_reverse, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(torque_current_available_reverse, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->inverter_status, 0u, 0xffu);

    return (8);
}

int c11_mcuf_status_feedback_unpack(
    struct c11_mcuf_status_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t torque_current_available_forward;
    uint16_t torque_current_available_reverse;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    torque_current_available_forward = 0u;
    torque_current_available_forward |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    torque_current_available_forward |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->torque_current_available_forward = (int16_t)torque_current_available_forward;
    torque_current_available_reverse = 0u;
    torque_current_available_reverse |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    torque_current_available_reverse |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->torque_current_available_reverse = (int16_t)torque_current_available_reverse;
    dst_p->inverter_status |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int16_t c11_mcuf_status_feedback_torque_current_available_forward_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcuf_status_feedback_torque_current_available_forward_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcuf_status_feedback_torque_current_available_forward_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_mcuf_status_feedback_torque_current_available_reverse_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcuf_status_feedback_torque_current_available_reverse_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcuf_status_feedback_torque_current_available_reverse_is_in_range(int16_t value)
{
    return (value <= 32766);
}

uint8_t c11_mcuf_status_feedback_inverter_status_encode(double value)
{
    return (uint8_t)(value);
}

double c11_mcuf_status_feedback_inverter_status_decode(uint8_t value)
{
    return ((double)value);
}

bool c11_mcuf_status_feedback_inverter_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int c11_mcuf_torque_feedback_pack(
    uint8_t *dst_p,
    const struct c11_mcuf_torque_feedback_t *src_p,
    size_t size)
{
    uint16_t dc_link_current;
    uint16_t speed_measured;
    uint16_t torque_current_measured;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    torque_current_measured = (uint16_t)src_p->torque_current_measured;
    dst_p[0] |= pack_left_shift_u16(torque_current_measured, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(torque_current_measured, 8u, 0xffu);
    speed_measured = (uint16_t)src_p->speed_measured;
    dst_p[2] |= pack_left_shift_u16(speed_measured, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(speed_measured, 8u, 0xffu);
    dc_link_current = (uint16_t)src_p->dc_link_current;
    dst_p[4] |= pack_left_shift_u16(dc_link_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(dc_link_current, 8u, 0xffu);

    return (8);
}

int c11_mcuf_torque_feedback_unpack(
    struct c11_mcuf_torque_feedback_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t dc_link_current;
    uint16_t speed_measured;
    uint16_t torque_current_measured;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    torque_current_measured = 0u;
    torque_current_measured |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    torque_current_measured |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->torque_current_measured = (int16_t)torque_current_measured;
    speed_measured = 0u;
    speed_measured |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    speed_measured |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->speed_measured = (int16_t)speed_measured;
    dc_link_current = 0u;
    dc_link_current |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dc_link_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->dc_link_current = (int16_t)dc_link_current;

    return (0);
}

int16_t c11_mcuf_torque_feedback_torque_current_measured_encode(double value)
{
    return (int16_t)(value / 0.0625);
}

double c11_mcuf_torque_feedback_torque_current_measured_decode(int16_t value)
{
    return ((double)value * 0.0625);
}

bool c11_mcuf_torque_feedback_torque_current_measured_is_in_range(int16_t value)
{
    return (value <= 32766);
}

int16_t c11_mcuf_torque_feedback_speed_measured_encode(double value)
{
    return (int16_t)(value);
}

double c11_mcuf_torque_feedback_speed_measured_decode(int16_t value)
{
    return ((double)value);
}

bool c11_mcuf_torque_feedback_speed_measured_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t c11_mcuf_torque_feedback_dc_link_current_encode(double value)
{
    return (int16_t)(value);
}

double c11_mcuf_torque_feedback_dc_link_current_decode(int16_t value)
{
    return ((double)value);
}

bool c11_mcuf_torque_feedback_dc_link_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}
